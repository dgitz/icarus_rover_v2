<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>icarus_rover_v2: Guide to MAVLink2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">icarus_rover_v2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Guide to MAVLink2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>MAVLink2 is a new variant of the MAVLink protocol designed to bring more flexibility and security to MAVLink communication.</p>
<p>A background document on the MAVLink2 design is available here:</p>
<p><a href="https://docs.google.com/document/d/1XtbD0ORNkhZ8eKrsbSIZNLyg9sFRXMXbsR2mp37KbIg/edit?usp=sharing">https://docs.google.com/document/d/1XtbD0ORNkhZ8eKrsbSIZNLyg9sFRXMXbsR2mp37KbIg/edit?usp=sharing</a></p>
<p>it is suggested that you start by reading that document.</p>
<p>The key features of MAVLink2 are:</p>
<ul>
<li>support for more than 256 message IDs (24 bit message ID)</li>
<li>support for packet signing</li>
<li>support for extending existing MAVLink messages</li>
<li>support for variable length arrays</li>
</ul>
<p>The first 3 features in this list are implemented now and ready for testing. The last feature is not implemented yet.</p>
<p>Most of the rest of this document is a guide for programmers interested in using MAVLink2 in their applications. The two language bindings that are covered are C and Python. Bindings for MAVLink2 for other languages are not implemented yet.</p>
<h2>Using the C implementation</h2>
<p>Using the C implementation of MAVLink2 is very similar to using the existing MAVLink1 implementation. You start by generating the MAVLink2 headers using mavgen.py, but passing the &ndash;wire-protocol=2.0 option. For example:</p>
<div class="fragment"><div class="line">mavgen.py --lang C message_definitions/v1.0/ardupilotmega.xml -o generator/C/include_v2.0 --wire-protocol=2.0</div></div><!-- fragment --><p>This will generate a set of C headers in the generator/C/include_v2.0 directory. These headers offer the same range of APIs as was offered by MAVLink1. The major changes from an API perspective are:</p>
<ul>
<li>you don't need to provide a message CRC table any more, or message length table. These have been folded into a single packed table, replacing the old table which was indexed by msgId. That was necessary to cope with the much larger 24 bit namespace of message IDs.</li>
</ul>
<h3>Sending and receiving MAVLink1 packets</h3>
<p>The C implementation of MAVLink2 supports sending and receiving MAVLink1 packets as well. To force sending MAVLink1 packets on a particular channel you change the flags field of the status object. For example:</p>
<div class="fragment"><div class="line">mavlink_status_t *status = mavlink_get_channel_status(MAVLINK_COMM_0);</div><div class="line">status-&gt;flags |= MAVLINK_STATUS_FLAG_OUT_MAVLINK1;</div></div><!-- fragment --><p>that will cause subsequent packets on the given channel to be sent as MAVLink1.</p>
<p>Incoming MAVLink1 packets will be automatically handled as MAVLink1. If you need to determine if a particular message was received as MAVLink1 or MAVLink2 then you can use the magic field of the message, like this:</p>
<div class="fragment"><div class="line">if (msg-&gt;magic = MAVLINK_STX_MAVLINK1) {</div><div class="line">   printf(&quot;This is a MAVLink1 message\n&quot;);</div><div class="line">}</div></div><!-- fragment --><p>In most cases this should not be necessary as the xml message definition files for MAVLink1 and MAVLink2 are the same, so you can treat incoming MAVLink1 messages the same as MAVLink2 messages.</p>
<p>Note that MAVLink1 is restricted to messageIDs less than 256, so any messages with a higher messageID won't be received as MAVLink1.</p>
<h3>Handling message extensions</h3>
<p>The XML for messages can contain extensions that are optional in the protocol. This allows for extra fields to be added to a message. For example:</p>
<div class="fragment"><div class="line">&lt;message id=&quot;152&quot; name=&quot;MEMINFO&quot;&gt;</div><div class="line">  &lt;description&gt;state of APM memory&lt;/description&gt;</div><div class="line">  &lt;field name=&quot;brkval&quot; type=&quot;uint16_t&quot;&gt;heap top&lt;/field&gt;</div><div class="line">  &lt;field name=&quot;freemem&quot; type=&quot;uint16_t&quot;&gt;free memory&lt;/field&gt;</div><div class="line">  &lt;extensions/&gt;</div><div class="line">  &lt;field name=&quot;extrafield1&quot; type=&quot;uint8_t&quot;&gt;extension1&lt;/field&gt;</div><div class="line">  &lt;field name=&quot;extrafield2&quot; type=&quot;uint32_t&quot;&gt;extension2&lt;/field&gt;</div><div class="line">&lt;/message&gt;</div></div><!-- fragment --><p>the fields after the extensions line are extended fields. The rules for extended messages are:</p>
<ul>
<li>if sent as a MAVLink1 message then extended fields are not sent</li>
<li>if received by an implementation that doesn't have the extended fields then the fields will not be seen</li>
<li>if sent by an implementation that doesn't have the extended fields then the recipient will see zero values for the extended fields</li>
</ul>
<h3>Handling message signing</h3>
<p>One of the key features of MAVLink2 is support for signing of messages. To enable signing in your application you will need to add some additional code. In particular you will need to add:</p>
<ul>
<li>code to handle the SETUP_SIGNING message</li>
<li>code to setup and teardown signing on a link</li>
<li>code to save and load the secret key and timestamp in persistent storage</li>
<li>a callback to allow for accepting of certain kinds of unsigned messages</li>
</ul>
<p>Example code in ArduPilot for each of these pieces if available here:</p>
<p><a href="https://github.com/tridge/ardupilot/blob/mavlink2-wip/libraries/GCS_MAVLink/GCS_Signing.cpp">https://github.com/tridge/ardupilot/blob/mavlink2-wip/libraries/GCS_MAVLink/GCS_Signing.cpp</a></p>
<h3>Handling SETUP_SIGNING</h3>
<p>The SETUP_SIGNING message is the mechanism for a GCS to setup a signing key on a MAVLink2 device. It takes a 32 byte secret key and an initial timestamp. The method of generating the 32 byte secret key is up to the GCS implementation, although it is suggested that all GCS implementations should support the use of a sha256 hash of a user provided passphrase.</p>
<h3>Handling timestamps</h3>
<p>The timestamp is a 64 bit number, and is in units of 10 microseconds since 1st January 2015. For systems where the time since 1/1/1970 is available (the unix epoch) you can use an offset in seconds of 1420070400.</p>
<p>Storage and handling of the timestamp is critical to the security of the signing system. The rules are:</p>
<ul>
<li>the current timestamp should be stored regularly in persistent storage (suggested at least once a minute)</li>
<li>the timestamp used on startup should be the maximum of the timestamp implied by the system clock and the stored timestamp</li>
<li>if the system does not have a RTC mechanism then it should update its timestamp when GPS lock is achieved. The maximum of the timestamp from the GPS and the stored timestamp should be used</li>
<li>the timestamp should be incremented by one on each message send. This is done for you by the generated headers.</li>
<li>when a correctly signed message is decoded the timestamp should be replaced by the timestamp of the incoming message if that timestamp is greater than the current timestamp. This is done for you by the generated headers</li>
<li>the timestamp on incoming signed messages should be checked against the previous timestamp for the incoming (linkID,srcSystem,SrcComponent) tuple and the message rejected if it is smaller. This is done for you by generated headers.</li>
<li>if there is no previous message with the given (linkID,srcSystem,SrcComponent) then the timestamp should be accepted if it not more than 6 million (one minute) behind the current timestamp</li>
</ul>
<h3>Enabling signing on a channel</h3>
<p>To enable signing on a channel you need to fill in two pointers in the status structure for the cnannel. The two pointed are:</p>
<div class="fragment"><div class="line">mavlink_signing_t *signing;</div><div class="line">mavlink_signing_streams_t *signing_streams;</div></div><!-- fragment --><p>The signing pointer controls signing for this stream. It is per-stream, and contains the secret key, the timestamp and a set of flags, plus an optional callback function for accepting unsigned packets. Typical setup would be:</p>
<div class="fragment"><div class="line">memcpy(signing.secret_key, key.secret_key, 32);</div><div class="line">signing.link_id = (uint8_t)chan;</div><div class="line">signing.timestamp = key.timestamp;</div><div class="line">signing.flags = MAVLINK_SIGNING_FLAG_SIGN_OUTGOING;</div><div class="line">signing.accept_unsigned_callback = accept_unsigned_callback;</div><div class="line">mavlink_status_t *status = mavlink_get_channel_status(chan);</div><div class="line">status.signing = &amp;signing;</div></div><!-- fragment --><p>The signing_streams pointer is a structure used to record the previous timestamp for a (linkId,srcSystem,SrcComponent) tuple. This must point to a structure that is common to all channels in order to prevent inter-channel replay attacks. Typical setup is:</p>
<div class="fragment"><div class="line">mavlink_status_t *status = mavlink_get_channel_status(chan);</div><div class="line">status.signing_streams = &amp;signing_streams;</div></div><!-- fragment --><p>The maximum number of signing streams supported is given by the MAVLINK_MAX_SIGNING_STREAMS macro. This defaults to 16, but it may be worth raising this for GCS implementations. If the C implementation runs out of signing streams then new streams will be rejected.</p>
<h3>Using the accept_unsigned_callback</h3>
<p>In the signing structure there is an optional accept_unsigned_callback function pointer. The C prototype for this function is:</p>
<div class="fragment"><div class="line">bool accept_unsigned_callback(const mavlink_status_t *status, uint32_t msgId);</div></div><!-- fragment --><p>If set in the signing structure then this function will be called on any unsigned packet (including all MAVLink1 packets) or any packet where the signature is incorrect. The function offers a way for the implementation to allow unsigned packets to be accepted.</p>
<p>The rules for what unsigned packets should be accepted is implementation specific, but it is suggested the following rules be considered:</p>
<ul>
<li>have a mechanism for marking a particular communication channel as being secure (such as a USB connection) to allow for signing setup.</li>
<li>always accept RADIO_STATUS packets for feedback from 3DR radios (which don't do signing)</li>
</ul>
<p>For example:</p>
<div class="fragment"><div class="line">static const uint32_t accept_list[] = {</div><div class="line">    MAVLINK_MSG_ID_RADIO_STATUS</div><div class="line">};</div><div class="line"></div><div class="line">static bool accept_unsigned_callback(const mavlink_status_t *status, uint32_t msgId)</div><div class="line">{</div><div class="line">    if (status == mavlink_get_channel_status(MAVLINK_COMM_0)) {</div><div class="line">        // always accept channel 0, assumed to be secure channel. This</div><div class="line">        // is USB on PX4 boards</div><div class="line">        return true;</div><div class="line">    }</div><div class="line">    for (uint8_t i=0; i&lt;ARRAY_SIZE(accept_list); i++) {</div><div class="line">        if (accept_list[i] == msgId) {</div><div class="line">            return true;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    return false;</div><div class="line">}</div></div><!-- fragment --><h3>Handling link IDs</h3>
<p>The purpose of the link_id field in the MAVLink2 signing structure is to prevent cross-channel replay attacks. Without the link_id an attacker could record a packet (such as a disarm request) on one channel, then play it back on a different channel.</p>
<p>The intention with the link IDs is that each channel of communication between an autopilot and a GCS uses a different link ID. There is no requirement that the same link ID be used in both directions however.</p>
<p>For C implementations the obvious mechanism is to use the MAVLink channel number as the link ID. That works well for an autopilot, but runs into an issue for a GCS implementation. The issue is that a user may launch multiple GCS instances talking to the same autopilot via different communication links (such as two radios, or USB and a radio). These multiple GCS instances will not be aware of each other, and so may choose the same link ID. If that happens then a large number of correctly signed packets will be rejected by the autopilot as they will have timestamps that are older than the timestamp received for the same stream tuple on the other communication link.</p>
<p>The solution that I have adopted for MAVProxy is this:</p>
<div class="fragment"><div class="line">if (msg.get_signed() and</div><div class="line">    self.mav.signing.link_id == 0 and</div><div class="line">    msg.get_link_id() != 0 and</div><div class="line">    self.target_system == msg.get_srcSystem() and</div><div class="line">    self.target_component == msg.get_srcComponent()):</div><div class="line">    # change to link_id from incoming packet</div><div class="line">    self.mav.signing.link_id = msg.get_link_id()</div></div><!-- fragment --><p>what that says is that if the current link ID in use by MAVProxy is zero, and it receives a correctly signed packet with a non-zero link ID then it switches link ID to the one from the incoming packet.</p>
<p>The has the effect of making the GCS slave its link ID to the link ID of the autopilot.</p>
<h3>Negotiating MAVLink2</h3>
<p>It is expected that vehicle and GCS implementations will support both MAVLink1 and MAVLink2 for quite some time. We would like most users to receive the benefit of MAVLink2, while still supporting implementations that don't yet support MAVLink2.</p>
<p>The following is meant to capture best practice for vehicle firmware and GCS authors:</p>
<ul>
<li>vehicle implementations should have a way to enable/disable the sending of MAVLink2 messages. This should preferably be on a per-link basis to allow for some peripherals to be MAVLink1 while others are MAVLink2. It is acceptable for this option to require a reboot of the flight controller to take effect.</li>
<li>if signing is enabled and MAVLink2 is enabled then the vehicle should immediately start sending MAVLink2 on startup</li>
<li>if signing is not enabled and MAVLink2 is enabled then the vehicle may choose to start by sending MAVLink1 and switch to MAVLink2 on a link when it first receives a MAVLink2 message on the link</li>
<li>vehicles should set the MAV_PROTOCOL_CAPABILITY_MAVLINK2 capability flag in the AUTOPILOT_VERSION message if MAVLink2 is available on a link. This should be set in the case where the link is currently sending MAVLink1 packets but MAVLink2 packets will be accepted and will cause a switch to MAVLink2</li>
<li>GCS implementations can choose to either automatically switch to MAVLink2 where available or to have a configuration option for MAVLink2</li>
<li>if the GCS chooses to use a configuration option then when the option is enabled it should send MAVLink2 on starting the link</li>
<li>if the GCS chooses to use automatic switching then it should switch to sending MAVLink2 if either it receives a MAVLink2 message on the link or by asking for the AUTOPILOT_VERSION message to be sent and seeing the MAV_PROTOCOL_CAPABILITY_MAVLINK2 flag is set </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
